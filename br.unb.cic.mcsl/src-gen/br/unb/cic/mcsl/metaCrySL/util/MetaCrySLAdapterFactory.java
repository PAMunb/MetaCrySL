/**
 * generated by Xtext 2.22.0
 */
package br.unb.cic.mcsl.metaCrySL.util;

import br.unb.cic.mcsl.metaCrySL.AggregateList;
import br.unb.cic.mcsl.metaCrySL.ChoiceExp;
import br.unb.cic.mcsl.metaCrySL.Event;
import br.unb.cic.mcsl.metaCrySL.EventAggregate;
import br.unb.cic.mcsl.metaCrySL.EventExp;
import br.unb.cic.mcsl.metaCrySL.EventMethod;
import br.unb.cic.mcsl.metaCrySL.EventSpec;
import br.unb.cic.mcsl.metaCrySL.Forbidden;
import br.unb.cic.mcsl.metaCrySL.ForbiddenMethod;
import br.unb.cic.mcsl.metaCrySL.ForbiddenSpec;
import br.unb.cic.mcsl.metaCrySL.Formal;
import br.unb.cic.mcsl.metaCrySL.FormalArg;
import br.unb.cic.mcsl.metaCrySL.FormalArgs;
import br.unb.cic.mcsl.metaCrySL.MetaCrySLPackage;
import br.unb.cic.mcsl.metaCrySL.MethodDef;
import br.unb.cic.mcsl.metaCrySL.Model;
import br.unb.cic.mcsl.metaCrySL.ObjectSpec;
import br.unb.cic.mcsl.metaCrySL.OneOrMore;
import br.unb.cic.mcsl.metaCrySL.Optional;
import br.unb.cic.mcsl.metaCrySL.OrderSpec;
import br.unb.cic.mcsl.metaCrySL.SequenceExp;
import br.unb.cic.mcsl.metaCrySL.Spec;
import br.unb.cic.mcsl.metaCrySL.Wildcard;
import br.unb.cic.mcsl.metaCrySL.ZeroOrMore;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl;

import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * The <b>Adapter Factory</b> for the model.
 * It provides an adapter <code>createXXX</code> method for each class of the model.
 * <!-- end-user-doc -->
 * @see br.unb.cic.mcsl.metaCrySL.MetaCrySLPackage
 * @generated
 */
public class MetaCrySLAdapterFactory extends AdapterFactoryImpl
{
  /**
   * The cached model package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected static MetaCrySLPackage modelPackage;

  /**
   * Creates an instance of the adapter factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public MetaCrySLAdapterFactory()
  {
    if (modelPackage == null)
    {
      modelPackage = MetaCrySLPackage.eINSTANCE;
    }
  }

  /**
   * Returns whether this factory is applicable for the type of the object.
   * <!-- begin-user-doc -->
   * This implementation returns <code>true</code> if the object is either the model's package or is an instance object of the model.
   * <!-- end-user-doc -->
   * @return whether this factory is applicable for the type of the object.
   * @generated
   */
  @Override
  public boolean isFactoryForType(Object object)
  {
    if (object == modelPackage)
    {
      return true;
    }
    if (object instanceof EObject)
    {
      return ((EObject)object).eClass().getEPackage() == modelPackage;
    }
    return false;
  }

  /**
   * The switch that delegates to the <code>createXXX</code> methods.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected MetaCrySLSwitch<Adapter> modelSwitch =
    new MetaCrySLSwitch<Adapter>()
    {
      @Override
      public Adapter caseModel(Model object)
      {
        return createModelAdapter();
      }
      @Override
      public Adapter caseSpec(Spec object)
      {
        return createSpecAdapter();
      }
      @Override
      public Adapter caseObjectSpec(ObjectSpec object)
      {
        return createObjectSpecAdapter();
      }
      @Override
      public Adapter caseObject(br.unb.cic.mcsl.metaCrySL.Object object)
      {
        return createObjectAdapter();
      }
      @Override
      public Adapter caseForbiddenSpec(ForbiddenSpec object)
      {
        return createForbiddenSpecAdapter();
      }
      @Override
      public Adapter caseForbiddenMethod(ForbiddenMethod object)
      {
        return createForbiddenMethodAdapter();
      }
      @Override
      public Adapter caseEventSpec(EventSpec object)
      {
        return createEventSpecAdapter();
      }
      @Override
      public Adapter caseEvent(Event object)
      {
        return createEventAdapter();
      }
      @Override
      public Adapter caseAggregateList(AggregateList object)
      {
        return createAggregateListAdapter();
      }
      @Override
      public Adapter caseMethodDef(MethodDef object)
      {
        return createMethodDefAdapter();
      }
      @Override
      public Adapter caseFormalArgs(FormalArgs object)
      {
        return createFormalArgsAdapter();
      }
      @Override
      public Adapter caseFormalArg(FormalArg object)
      {
        return createFormalArgAdapter();
      }
      @Override
      public Adapter caseOrderSpec(OrderSpec object)
      {
        return createOrderSpecAdapter();
      }
      @Override
      public Adapter caseEventExp(EventExp object)
      {
        return createEventExpAdapter();
      }
      @Override
      public Adapter caseForbidden(Forbidden object)
      {
        return createForbiddenAdapter();
      }
      @Override
      public Adapter caseEventMethod(EventMethod object)
      {
        return createEventMethodAdapter();
      }
      @Override
      public Adapter caseEventAggregate(EventAggregate object)
      {
        return createEventAggregateAdapter();
      }
      @Override
      public Adapter caseWildcard(Wildcard object)
      {
        return createWildcardAdapter();
      }
      @Override
      public Adapter caseFormal(Formal object)
      {
        return createFormalAdapter();
      }
      @Override
      public Adapter caseOptional(Optional object)
      {
        return createOptionalAdapter();
      }
      @Override
      public Adapter caseZeroOrMore(ZeroOrMore object)
      {
        return createZeroOrMoreAdapter();
      }
      @Override
      public Adapter caseOneOrMore(OneOrMore object)
      {
        return createOneOrMoreAdapter();
      }
      @Override
      public Adapter caseChoiceExp(ChoiceExp object)
      {
        return createChoiceExpAdapter();
      }
      @Override
      public Adapter caseSequenceExp(SequenceExp object)
      {
        return createSequenceExpAdapter();
      }
      @Override
      public Adapter defaultCase(EObject object)
      {
        return createEObjectAdapter();
      }
    };

  /**
   * Creates an adapter for the <code>target</code>.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param target the object to adapt.
   * @return the adapter for the <code>target</code>.
   * @generated
   */
  @Override
  public Adapter createAdapter(Notifier target)
  {
    return modelSwitch.doSwitch((EObject)target);
  }


  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Model <em>Model</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Model
   * @generated
   */
  public Adapter createModelAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Spec <em>Spec</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Spec
   * @generated
   */
  public Adapter createSpecAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.ObjectSpec <em>Object Spec</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.ObjectSpec
   * @generated
   */
  public Adapter createObjectSpecAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Object <em>Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Object
   * @generated
   */
  public Adapter createObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.ForbiddenSpec <em>Forbidden Spec</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.ForbiddenSpec
   * @generated
   */
  public Adapter createForbiddenSpecAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.ForbiddenMethod <em>Forbidden Method</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.ForbiddenMethod
   * @generated
   */
  public Adapter createForbiddenMethodAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.EventSpec <em>Event Spec</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.EventSpec
   * @generated
   */
  public Adapter createEventSpecAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Event <em>Event</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Event
   * @generated
   */
  public Adapter createEventAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.AggregateList <em>Aggregate List</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.AggregateList
   * @generated
   */
  public Adapter createAggregateListAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.MethodDef <em>Method Def</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.MethodDef
   * @generated
   */
  public Adapter createMethodDefAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.FormalArgs <em>Formal Args</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.FormalArgs
   * @generated
   */
  public Adapter createFormalArgsAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.FormalArg <em>Formal Arg</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.FormalArg
   * @generated
   */
  public Adapter createFormalArgAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.OrderSpec <em>Order Spec</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.OrderSpec
   * @generated
   */
  public Adapter createOrderSpecAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.EventExp <em>Event Exp</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.EventExp
   * @generated
   */
  public Adapter createEventExpAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Forbidden <em>Forbidden</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Forbidden
   * @generated
   */
  public Adapter createForbiddenAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.EventMethod <em>Event Method</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.EventMethod
   * @generated
   */
  public Adapter createEventMethodAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.EventAggregate <em>Event Aggregate</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.EventAggregate
   * @generated
   */
  public Adapter createEventAggregateAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Wildcard <em>Wildcard</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Wildcard
   * @generated
   */
  public Adapter createWildcardAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Formal <em>Formal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Formal
   * @generated
   */
  public Adapter createFormalAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.Optional <em>Optional</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.Optional
   * @generated
   */
  public Adapter createOptionalAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.ZeroOrMore <em>Zero Or More</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.ZeroOrMore
   * @generated
   */
  public Adapter createZeroOrMoreAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.OneOrMore <em>One Or More</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.OneOrMore
   * @generated
   */
  public Adapter createOneOrMoreAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.ChoiceExp <em>Choice Exp</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.ChoiceExp
   * @generated
   */
  public Adapter createChoiceExpAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link br.unb.cic.mcsl.metaCrySL.SequenceExp <em>Sequence Exp</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see br.unb.cic.mcsl.metaCrySL.SequenceExp
   * @generated
   */
  public Adapter createSequenceExpAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for the default case.
   * <!-- begin-user-doc -->
   * This default implementation returns null.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @generated
   */
  public Adapter createEObjectAdapter()
  {
    return null;
  }

} //MetaCrySLAdapterFactory
