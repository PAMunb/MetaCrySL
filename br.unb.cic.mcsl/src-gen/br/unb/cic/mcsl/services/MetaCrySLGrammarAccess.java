/*
 * generated by Xtext 2.22.0
 */
package br.unb.cic.mcsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.xbase.services.XtypeGrammarAccess;

@Singleton
public class MetaCrySLGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.Model");
		private final Assignment cMetaCrySLAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cMetaCrySLSpecParserRuleCall_0 = (RuleCall)cMetaCrySLAssignment.eContents().get(0);
		
		//Model:
		//	metaCrySL=Spec;
		@Override public ParserRule getRule() { return rule; }
		
		//metaCrySL=Spec
		public Assignment getMetaCrySLAssignment() { return cMetaCrySLAssignment; }
		
		//Spec
		public RuleCall getMetaCrySLSpecParserRuleCall_0() { return cMetaCrySLSpecParserRuleCall_0; }
	}
	public class SpecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.Spec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cABSTRACTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSPECKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cClassNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cClassNameJvmTypeReferenceParserRuleCall_2_0 = (RuleCall)cClassNameAssignment_2.eContents().get(0);
		private final Assignment cObjectSpecAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjectSpecObjectSpecParserRuleCall_3_0 = (RuleCall)cObjectSpecAssignment_3.eContents().get(0);
		private final Assignment cEventSpecAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEventSpecEventSpecParserRuleCall_4_0 = (RuleCall)cEventSpecAssignment_4.eContents().get(0);
		private final Assignment cOrderSpecAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOrderSpecOrderSpecParserRuleCall_5_0 = (RuleCall)cOrderSpecAssignment_5.eContents().get(0);
		
		///* Spec rule 
		// * 
		// * This is the start symbol of our MetaCrySL grammar. 
		// * In MetaCrySL, we can annotate a specification
		// * as being abstract and a spec can also refer to an 
		// * abstract type. Each specification comprises 
		// * (or might comprise) definitions for object 
		// * declarations, events and order, constraints, 
		// * and so on. 
		// */ Spec:
		//	'ABSTRACT'? 'SPEC' className=JvmTypeReference
		//	objectSpec=ObjectSpec?
		//	eventSpec=EventSpec?
		//	orderSpec=OrderSpec?;
		@Override public ParserRule getRule() { return rule; }
		
		//'ABSTRACT'? 'SPEC' className=JvmTypeReference objectSpec=ObjectSpec? eventSpec=EventSpec? orderSpec=OrderSpec?
		public Group getGroup() { return cGroup; }
		
		//'ABSTRACT'?
		public Keyword getABSTRACTKeyword_0() { return cABSTRACTKeyword_0; }
		
		//'SPEC'
		public Keyword getSPECKeyword_1() { return cSPECKeyword_1; }
		
		//className=JvmTypeReference
		public Assignment getClassNameAssignment_2() { return cClassNameAssignment_2; }
		
		//JvmTypeReference
		public RuleCall getClassNameJvmTypeReferenceParserRuleCall_2_0() { return cClassNameJvmTypeReferenceParserRuleCall_2_0; }
		
		//objectSpec=ObjectSpec?
		public Assignment getObjectSpecAssignment_3() { return cObjectSpecAssignment_3; }
		
		//ObjectSpec
		public RuleCall getObjectSpecObjectSpecParserRuleCall_3_0() { return cObjectSpecObjectSpecParserRuleCall_3_0; }
		
		//eventSpec=EventSpec?
		public Assignment getEventSpecAssignment_4() { return cEventSpecAssignment_4; }
		
		//EventSpec
		public RuleCall getEventSpecEventSpecParserRuleCall_4_0() { return cEventSpecEventSpecParserRuleCall_4_0; }
		
		//orderSpec=OrderSpec?
		public Assignment getOrderSpecAssignment_5() { return cOrderSpecAssignment_5; }
		
		//OrderSpec
		public RuleCall getOrderSpecOrderSpecParserRuleCall_5_0() { return cOrderSpecOrderSpecParserRuleCall_5_0; }
	}
	public class ObjectSpecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.ObjectSpec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObjectSpecAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOBJECTSKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cObjectsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjectsObjectParserRuleCall_3_0 = (RuleCall)cObjectsAssignment_3.eContents().get(0);
		
		///* ObjectSpec rule
		// * 
		// * It corresponds to the declaration of the 
		// * variables (names) used throughout the 
		// * specification. 
		// */ ObjectSpec:
		//	{ObjectSpec} 'OBJECTS' ':' objects+=Object+;
		@Override public ParserRule getRule() { return rule; }
		
		//{ObjectSpec} 'OBJECTS' ':' objects+=Object+
		public Group getGroup() { return cGroup; }
		
		//{ObjectSpec}
		public Action getObjectSpecAction_0() { return cObjectSpecAction_0; }
		
		//'OBJECTS'
		public Keyword getOBJECTSKeyword_1() { return cOBJECTSKeyword_1; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//objects+=Object+
		public Assignment getObjectsAssignment_3() { return cObjectsAssignment_3; }
		
		//Object
		public RuleCall getObjectsObjectParserRuleCall_3_0() { return cObjectsObjectParserRuleCall_3_0; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.Object");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObjectAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeJvmTypeReferenceParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cVarNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarNameIDTerminalRuleCall_2_0 = (RuleCall)cVarNameAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* Object rule
		// * 
		// * Allows the specification of a typed 
		// * variable that can be used in the remaining 
		// * sections of the specification. 
		// */ Object:
		//	{Object} type=JvmTypeReference varName=ID ';';
		@Override public ParserRule getRule() { return rule; }
		
		//{Object} type=JvmTypeReference varName=ID ';'
		public Group getGroup() { return cGroup; }
		
		//{Object}
		public Action getObjectAction_0() { return cObjectAction_0; }
		
		//type=JvmTypeReference
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//JvmTypeReference
		public RuleCall getTypeJvmTypeReferenceParserRuleCall_1_0() { return cTypeJvmTypeReferenceParserRuleCall_1_0; }
		
		//varName=ID
		public Assignment getVarNameAssignment_2() { return cVarNameAssignment_2; }
		
		//ID
		public RuleCall getVarNameIDTerminalRuleCall_2_0() { return cVarNameIDTerminalRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class EventSpecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.EventSpec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEventSpecAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEVENTSKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEventsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEventsEventParserRuleCall_2_0 = (RuleCall)cEventsAssignment_2.eContents().get(0);
		
		///* EventSpec rule 
		// * 
		// * This rule defines the EVENTS session. It should accept 
		// * the following: 
		// *  
		// *   EVENTS: 
		// *     c1 : method1();           //event method
		// *     c2 : method2(int x);      //event method
		// *     
		// *     cs := c1 | c2 ;           //event aggregate
		// */ EventSpec:
		//	{EventSpec} 'EVENTS' events+=Event+;
		@Override public ParserRule getRule() { return rule; }
		
		//{EventSpec} 'EVENTS' events+=Event+
		public Group getGroup() { return cGroup; }
		
		//{EventSpec}
		public Action getEventSpecAction_0() { return cEventSpecAction_0; }
		
		//'EVENTS'
		public Keyword getEVENTSKeyword_1() { return cEVENTSKeyword_1; }
		
		//events+=Event+
		public Assignment getEventsAssignment_2() { return cEventsAssignment_2; }
		
		//Event
		public RuleCall getEventsEventParserRuleCall_2_0() { return cEventsEventParserRuleCall_2_0; }
	}
	public class EventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.Event");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cEventMethodAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cLabelAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final RuleCall cLabelIDTerminalRuleCall_0_1_0_0 = (RuleCall)cLabelAssignment_0_1_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Assignment cVarAssignment_0_2_0 = (Assignment)cGroup_0_2.eContents().get(0);
		private final RuleCall cVarIDTerminalRuleCall_0_2_0_0 = (RuleCall)cVarAssignment_0_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cMethodAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cMethodMethodDefParserRuleCall_0_3_0 = (RuleCall)cMethodAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cEventAggregateAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cLabelAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cLabelIDTerminalRuleCall_1_1_0_0 = (RuleCall)cLabelAssignment_1_1_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cAggregateAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cAggregateAggregateListParserRuleCall_1_2_0 = (RuleCall)cAggregateAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		///* Event rule
		// * 
		// * An event is either a labeled method or an 
		// * aggregation of labels. Note that we can assign 
		// * a 'method call' to a variable. 
		// */ Event:
		//	{EventMethod} (label=ID ':') (var=ID '=')? method=MethodDef ';'
		//	| {EventAggregate} (label=ID ':=') aggregate=AggregateList ';';
		@Override public ParserRule getRule() { return rule; }
		
		//{EventMethod} (label=ID ':') (var=ID '=')? method=MethodDef ';' | {EventAggregate} (label=ID ':=')
		//aggregate=AggregateList ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{EventMethod} (label=ID ':') (var=ID '=')? method=MethodDef ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//{EventMethod}
		public Action getEventMethodAction_0_0() { return cEventMethodAction_0_0; }
		
		//(label=ID ':')
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//label=ID
		public Assignment getLabelAssignment_0_1_0() { return cLabelAssignment_0_1_0; }
		
		//ID
		public RuleCall getLabelIDTerminalRuleCall_0_1_0_0() { return cLabelIDTerminalRuleCall_0_1_0_0; }
		
		//':'
		public Keyword getColonKeyword_0_1_1() { return cColonKeyword_0_1_1; }
		
		//(var=ID '=')?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//var=ID
		public Assignment getVarAssignment_0_2_0() { return cVarAssignment_0_2_0; }
		
		//ID
		public RuleCall getVarIDTerminalRuleCall_0_2_0_0() { return cVarIDTerminalRuleCall_0_2_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_2_1() { return cEqualsSignKeyword_0_2_1; }
		
		//method=MethodDef
		public Assignment getMethodAssignment_0_3() { return cMethodAssignment_0_3; }
		
		//MethodDef
		public RuleCall getMethodMethodDefParserRuleCall_0_3_0() { return cMethodMethodDefParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_4() { return cSemicolonKeyword_0_4; }
		
		//{EventAggregate} (label=ID ':=') aggregate=AggregateList ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//{EventAggregate}
		public Action getEventAggregateAction_1_0() { return cEventAggregateAction_1_0; }
		
		//(label=ID ':=')
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//label=ID
		public Assignment getLabelAssignment_1_1_0() { return cLabelAssignment_1_1_0; }
		
		//ID
		public RuleCall getLabelIDTerminalRuleCall_1_1_0_0() { return cLabelIDTerminalRuleCall_1_1_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_1_1_1() { return cColonEqualsSignKeyword_1_1_1; }
		
		//aggregate=AggregateList
		public Assignment getAggregateAssignment_1_2() { return cAggregateAssignment_1_2; }
		
		//AggregateList
		public RuleCall getAggregateAggregateListParserRuleCall_1_2_0() { return cAggregateAggregateListParserRuleCall_1_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_3() { return cSemicolonKeyword_1_3; }
	}
	public class AggregateListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.AggregateList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelsIDTerminalRuleCall_0_0 = (RuleCall)cLabelsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cVerticalLineKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cLabelsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLabelsIDTerminalRuleCall_1_1_0 = (RuleCall)cLabelsAssignment_1_1.eContents().get(0);
		
		///* AggregateList rule. 
		// * 
		// * Represents a list of labels: 'l1 | l2 | l3'
		// */ AggregateList:
		//	labels+=ID ('|' labels+=ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//labels+=ID ('|' labels+=ID)*
		public Group getGroup() { return cGroup; }
		
		//labels+=ID
		public Assignment getLabelsAssignment_0() { return cLabelsAssignment_0; }
		
		//ID
		public RuleCall getLabelsIDTerminalRuleCall_0_0() { return cLabelsIDTerminalRuleCall_0_0; }
		
		//('|' labels+=ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_0() { return cVerticalLineKeyword_1_0; }
		
		//labels+=ID
		public Assignment getLabelsAssignment_1_1() { return cLabelsAssignment_1_1; }
		
		//ID
		public RuleCall getLabelsIDTerminalRuleCall_1_1_0() { return cLabelsIDTerminalRuleCall_1_1_0; }
	}
	public class MethodDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.MethodDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMethodNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMethodNameIDTerminalRuleCall_0_0 = (RuleCall)cMethodNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgsFormalArgsParserRuleCall_2_0 = (RuleCall)cArgsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* MethodDef rule. 
		// * 
		// * It should accept 'method()' or method(int x, int y)
		// * 
		// * (note) 
		// * this way to express lists, with a list 
		// * separator in XText, is really weird. 
		// */ MethodDef:
		//	methodName=ID '(' args?=FormalArgs? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//methodName=ID '(' args?=FormalArgs? ')'
		public Group getGroup() { return cGroup; }
		
		//methodName=ID
		public Assignment getMethodNameAssignment_0() { return cMethodNameAssignment_0; }
		
		//ID
		public RuleCall getMethodNameIDTerminalRuleCall_0_0() { return cMethodNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//args?=FormalArgs?
		public Assignment getArgsAssignment_2() { return cArgsAssignment_2; }
		
		//FormalArgs
		public RuleCall getArgsFormalArgsParserRuleCall_2_0() { return cArgsFormalArgsParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class FormalArgsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.FormalArgs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cArgsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cArgsFormalArgCrossReference_0_0 = (CrossReference)cArgsAssignment_0.eContents().get(0);
		private final RuleCall cArgsFormalArgIDTerminalRuleCall_0_0_1 = (RuleCall)cArgsFormalArgCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cArgsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cArgsFormalArgCrossReference_1_1_0 = (CrossReference)cArgsAssignment_1_1.eContents().get(0);
		private final RuleCall cArgsFormalArgIDTerminalRuleCall_1_1_0_1 = (RuleCall)cArgsFormalArgCrossReference_1_1_0.eContents().get(1);
		
		///* FormalArgs rule
		// * 
		// * Represents a list of formal arguments. 
		// */ FormalArgs:
		//	args+=[FormalArg] (',' args+=[FormalArg])*;
		@Override public ParserRule getRule() { return rule; }
		
		//args+=[FormalArg] (',' args+=[FormalArg])*
		public Group getGroup() { return cGroup; }
		
		//args+=[FormalArg]
		public Assignment getArgsAssignment_0() { return cArgsAssignment_0; }
		
		//[FormalArg]
		public CrossReference getArgsFormalArgCrossReference_0_0() { return cArgsFormalArgCrossReference_0_0; }
		
		//ID
		public RuleCall getArgsFormalArgIDTerminalRuleCall_0_0_1() { return cArgsFormalArgIDTerminalRuleCall_0_0_1; }
		
		//(',' args+=[FormalArg])*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//args+=[FormalArg]
		public Assignment getArgsAssignment_1_1() { return cArgsAssignment_1_1; }
		
		//[FormalArg]
		public CrossReference getArgsFormalArgCrossReference_1_1_0() { return cArgsFormalArgCrossReference_1_1_0; }
		
		//ID
		public RuleCall getArgsFormalArgIDTerminalRuleCall_1_1_0_1() { return cArgsFormalArgIDTerminalRuleCall_1_1_0_1; }
	}
	public class FormalArgElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.FormalArg");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cWildcardAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword c_Keyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFormalAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cArgumentAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cArgumentJvmArgumentTypeReferenceParserRuleCall_1_1_0 = (RuleCall)cArgumentAssignment_1_1.eContents().get(0);
		
		///* FormalArg rule
		// * 
		// * It should accept a wild card ('_') or something like 'int x'  
		// */ FormalArg:
		//	{Wildcard} '_'
		//	| {Formal} argument=JvmArgumentTypeReference;
		@Override public ParserRule getRule() { return rule; }
		
		//{Wildcard} '_' | {Formal} argument=JvmArgumentTypeReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Wildcard} '_'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Wildcard}
		public Action getWildcardAction_0_0() { return cWildcardAction_0_0; }
		
		//'_'
		public Keyword get_Keyword_0_1() { return c_Keyword_0_1; }
		
		//{Formal} argument=JvmArgumentTypeReference
		public Group getGroup_1() { return cGroup_1; }
		
		//{Formal}
		public Action getFormalAction_1_0() { return cFormalAction_1_0; }
		
		//argument=JvmArgumentTypeReference
		public Assignment getArgumentAssignment_1_1() { return cArgumentAssignment_1_1; }
		
		//JvmArgumentTypeReference
		public RuleCall getArgumentJvmArgumentTypeReferenceParserRuleCall_1_1_0() { return cArgumentJvmArgumentTypeReferenceParserRuleCall_1_1_0; }
	}
	public class OrderSpecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.OrderSpec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOrderSpecAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cORDERKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOrderAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOrderEventExpParserRuleCall_2_0 = (RuleCall)cOrderAssignment_2.eContents().get(0);
		
		///* OrderSpec rule
		// * 
		// * Uses a regular expression on the labeled 
		// * events. 
		// */ OrderSpec:
		//	{OrderSpec} 'ORDER' order=EventExp;
		@Override public ParserRule getRule() { return rule; }
		
		//{OrderSpec} 'ORDER' order=EventExp
		public Group getGroup() { return cGroup; }
		
		//{OrderSpec}
		public Action getOrderSpecAction_0() { return cOrderSpecAction_0; }
		
		//'ORDER'
		public Keyword getORDERKeyword_1() { return cORDERKeyword_1; }
		
		//order=EventExp
		public Assignment getOrderAssignment_2() { return cOrderAssignment_2; }
		
		//EventExp
		public RuleCall getOrderEventExpParserRuleCall_2_0() { return cOrderEventExpParserRuleCall_2_0; }
	}
	public class EventExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.EventExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOptionalAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cExpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExpChoiceExpParserRuleCall_0_1_0 = (RuleCall)cExpAssignment_0_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cZeroOrMoreAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cExpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpChoiceExpParserRuleCall_1_1_0 = (RuleCall)cExpAssignment_1_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cOneOrMoreAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cExpAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpChoiceExpParserRuleCall_2_1_0 = (RuleCall)cExpAssignment_2_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cChoiceExpAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cExpAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cExpChoiceExpParserRuleCall_3_1_0 = (RuleCall)cExpAssignment_3_1.eContents().get(0);
		
		///* EventExp 
		// * 
		// * An expression language to declare the order of events 
		// * (or method calls). This order resembles a regular 
		// * expression. 
		// *  
		// * Here we use a well-known idiom to avoid left-recursion in 
		// * grammars, named left-factoring.  
		// * 
		// * Specifically to the context of XText, this video 
		// * might be useful to understand this design: 
		// * 
		// * https://www.youtube.com/watch?v=d3JymwcB_TM&feature=youtu.be
		// * 
		// * Note: It was necessary to allow the backtrack feature 
		// * here. Take a look at the mwe2 file.  
		// */ EventExp:
		//	{Optional} exp=ChoiceExp '?'
		//	| {ZeroOrMore} exp=ChoiceExp '*'
		//	| {OneOrMore} exp=ChoiceExp '+'
		//	| {ChoiceExp} exp=ChoiceExp;
		@Override public ParserRule getRule() { return rule; }
		
		//{Optional} exp=ChoiceExp '?' | {ZeroOrMore} exp=ChoiceExp '*' | {OneOrMore} exp=ChoiceExp '+' | {ChoiceExp}
		//exp=ChoiceExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Optional} exp=ChoiceExp '?'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Optional}
		public Action getOptionalAction_0_0() { return cOptionalAction_0_0; }
		
		//exp=ChoiceExp
		public Assignment getExpAssignment_0_1() { return cExpAssignment_0_1; }
		
		//ChoiceExp
		public RuleCall getExpChoiceExpParserRuleCall_0_1_0() { return cExpChoiceExpParserRuleCall_0_1_0; }
		
		//'?'
		public Keyword getQuestionMarkKeyword_0_2() { return cQuestionMarkKeyword_0_2; }
		
		//{ZeroOrMore} exp=ChoiceExp '*'
		public Group getGroup_1() { return cGroup_1; }
		
		//{ZeroOrMore}
		public Action getZeroOrMoreAction_1_0() { return cZeroOrMoreAction_1_0; }
		
		//exp=ChoiceExp
		public Assignment getExpAssignment_1_1() { return cExpAssignment_1_1; }
		
		//ChoiceExp
		public RuleCall getExpChoiceExpParserRuleCall_1_1_0() { return cExpChoiceExpParserRuleCall_1_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_2() { return cAsteriskKeyword_1_2; }
		
		//{OneOrMore} exp=ChoiceExp '+'
		public Group getGroup_2() { return cGroup_2; }
		
		//{OneOrMore}
		public Action getOneOrMoreAction_2_0() { return cOneOrMoreAction_2_0; }
		
		//exp=ChoiceExp
		public Assignment getExpAssignment_2_1() { return cExpAssignment_2_1; }
		
		//ChoiceExp
		public RuleCall getExpChoiceExpParserRuleCall_2_1_0() { return cExpChoiceExpParserRuleCall_2_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_2_2() { return cPlusSignKeyword_2_2; }
		
		//{ChoiceExp} exp=ChoiceExp
		public Group getGroup_3() { return cGroup_3; }
		
		//{ChoiceExp}
		public Action getChoiceExpAction_3_0() { return cChoiceExpAction_3_0; }
		
		//exp=ChoiceExp
		public Assignment getExpAssignment_3_1() { return cExpAssignment_3_1; }
		
		//ChoiceExp
		public RuleCall getExpChoiceExpParserRuleCall_3_1_0() { return cExpChoiceExpParserRuleCall_3_1_0; }
	}
	public class ChoiceExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.ChoiceExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSequenceExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cChoiceExpLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightSequenceExpParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//ChoiceExp EventExp:
		//	SequenceExp => ({ChoiceExp.left=current} '|' right=SequenceExp)*;
		@Override public ParserRule getRule() { return rule; }
		
		//SequenceExp => ({ChoiceExp.left=current} '|' right=SequenceExp)*
		public Group getGroup() { return cGroup; }
		
		//SequenceExp
		public RuleCall getSequenceExpParserRuleCall_0() { return cSequenceExpParserRuleCall_0; }
		
		//=> ({ChoiceExp.left=current} '|' right=SequenceExp)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({ChoiceExp.left=current} '|' right=SequenceExp)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ChoiceExp.left=current}
		public Action getChoiceExpLeftAction_1_0_0() { return cChoiceExpLeftAction_1_0_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_0_1() { return cVerticalLineKeyword_1_0_1; }
		
		//right=SequenceExp
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }
		
		//SequenceExp
		public RuleCall getRightSequenceExpParserRuleCall_1_0_2_0() { return cRightSequenceExpParserRuleCall_1_0_2_0; }
	}
	public class SequenceExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.SequenceExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSequenceExpLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightPrimaryExpParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//SequenceExp EventExp:
		//	PrimaryExp => ({SequenceExp.left=current} ',' right=PrimaryExp)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExp => ({SequenceExp.left=current} ',' right=PrimaryExp)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExp
		public RuleCall getPrimaryExpParserRuleCall_0() { return cPrimaryExpParserRuleCall_0; }
		
		//=> ({SequenceExp.left=current} ',' right=PrimaryExp)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({SequenceExp.left=current} ',' right=PrimaryExp)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{SequenceExp.left=current}
		public Action getSequenceExpLeftAction_1_0_0() { return cSequenceExpLeftAction_1_0_0; }
		
		//','
		public Keyword getCommaKeyword_1_0_1() { return cCommaKeyword_1_0_1; }
		
		//right=PrimaryExp
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }
		
		//PrimaryExp
		public RuleCall getRightPrimaryExpParserRuleCall_1_0_2_0() { return cRightPrimaryExpParserRuleCall_1_0_2_0; }
	}
	public class PrimaryExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "br.unb.cic.mcsl.MetaCrySL.PrimaryExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cLabelIDTerminalRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cChoiceExpParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PrimaryExp EventExp:
		//	label=ID
		//	| '(' ChoiceExp ')';
		@Override public ParserRule getRule() { return rule; }
		
		//label=ID | '(' ChoiceExp ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//label=ID
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }
		
		//ID
		public RuleCall getLabelIDTerminalRuleCall_0_0() { return cLabelIDTerminalRuleCall_0_0; }
		
		//'(' ChoiceExp ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//ChoiceExp
		public RuleCall getChoiceExpParserRuleCall_1_1() { return cChoiceExpParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	
	
	private final ModelElements pModel;
	private final SpecElements pSpec;
	private final ObjectSpecElements pObjectSpec;
	private final ObjectElements pObject;
	private final EventSpecElements pEventSpec;
	private final EventElements pEvent;
	private final AggregateListElements pAggregateList;
	private final MethodDefElements pMethodDef;
	private final FormalArgsElements pFormalArgs;
	private final FormalArgElements pFormalArg;
	private final OrderSpecElements pOrderSpec;
	private final EventExpElements pEventExp;
	private final ChoiceExpElements pChoiceExp;
	private final SequenceExpElements pSequenceExp;
	private final PrimaryExpElements pPrimaryExp;
	
	private final Grammar grammar;
	
	private final XtypeGrammarAccess gaXtype;

	@Inject
	public MetaCrySLGrammarAccess(GrammarProvider grammarProvider,
			XtypeGrammarAccess gaXtype) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaXtype = gaXtype;
		this.pModel = new ModelElements();
		this.pSpec = new SpecElements();
		this.pObjectSpec = new ObjectSpecElements();
		this.pObject = new ObjectElements();
		this.pEventSpec = new EventSpecElements();
		this.pEvent = new EventElements();
		this.pAggregateList = new AggregateListElements();
		this.pMethodDef = new MethodDefElements();
		this.pFormalArgs = new FormalArgsElements();
		this.pFormalArg = new FormalArgElements();
		this.pOrderSpec = new OrderSpecElements();
		this.pEventExp = new EventExpElements();
		this.pChoiceExp = new ChoiceExpElements();
		this.pSequenceExp = new SequenceExpElements();
		this.pPrimaryExp = new PrimaryExpElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("br.unb.cic.mcsl.MetaCrySL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public XtypeGrammarAccess getXtypeGrammarAccess() {
		return gaXtype;
	}

	
	//Model:
	//	metaCrySL=Spec;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///* Spec rule 
	// * 
	// * This is the start symbol of our MetaCrySL grammar. 
	// * In MetaCrySL, we can annotate a specification
	// * as being abstract and a spec can also refer to an 
	// * abstract type. Each specification comprises 
	// * (or might comprise) definitions for object 
	// * declarations, events and order, constraints, 
	// * and so on. 
	// */ Spec:
	//	'ABSTRACT'? 'SPEC' className=JvmTypeReference
	//	objectSpec=ObjectSpec?
	//	eventSpec=EventSpec?
	//	orderSpec=OrderSpec?;
	public SpecElements getSpecAccess() {
		return pSpec;
	}
	
	public ParserRule getSpecRule() {
		return getSpecAccess().getRule();
	}
	
	///* ObjectSpec rule
	// * 
	// * It corresponds to the declaration of the 
	// * variables (names) used throughout the 
	// * specification. 
	// */ ObjectSpec:
	//	{ObjectSpec} 'OBJECTS' ':' objects+=Object+;
	public ObjectSpecElements getObjectSpecAccess() {
		return pObjectSpec;
	}
	
	public ParserRule getObjectSpecRule() {
		return getObjectSpecAccess().getRule();
	}
	
	///* Object rule
	// * 
	// * Allows the specification of a typed 
	// * variable that can be used in the remaining 
	// * sections of the specification. 
	// */ Object:
	//	{Object} type=JvmTypeReference varName=ID ';';
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	///* EventSpec rule 
	// * 
	// * This rule defines the EVENTS session. It should accept 
	// * the following: 
	// *  
	// *   EVENTS: 
	// *     c1 : method1();           //event method
	// *     c2 : method2(int x);      //event method
	// *     
	// *     cs := c1 | c2 ;           //event aggregate
	// */ EventSpec:
	//	{EventSpec} 'EVENTS' events+=Event+;
	public EventSpecElements getEventSpecAccess() {
		return pEventSpec;
	}
	
	public ParserRule getEventSpecRule() {
		return getEventSpecAccess().getRule();
	}
	
	///* Event rule
	// * 
	// * An event is either a labeled method or an 
	// * aggregation of labels. Note that we can assign 
	// * a 'method call' to a variable. 
	// */ Event:
	//	{EventMethod} (label=ID ':') (var=ID '=')? method=MethodDef ';'
	//	| {EventAggregate} (label=ID ':=') aggregate=AggregateList ';';
	public EventElements getEventAccess() {
		return pEvent;
	}
	
	public ParserRule getEventRule() {
		return getEventAccess().getRule();
	}
	
	///* AggregateList rule. 
	// * 
	// * Represents a list of labels: 'l1 | l2 | l3'
	// */ AggregateList:
	//	labels+=ID ('|' labels+=ID)*;
	public AggregateListElements getAggregateListAccess() {
		return pAggregateList;
	}
	
	public ParserRule getAggregateListRule() {
		return getAggregateListAccess().getRule();
	}
	
	///* MethodDef rule. 
	// * 
	// * It should accept 'method()' or method(int x, int y)
	// * 
	// * (note) 
	// * this way to express lists, with a list 
	// * separator in XText, is really weird. 
	// */ MethodDef:
	//	methodName=ID '(' args?=FormalArgs? ')';
	public MethodDefElements getMethodDefAccess() {
		return pMethodDef;
	}
	
	public ParserRule getMethodDefRule() {
		return getMethodDefAccess().getRule();
	}
	
	///* FormalArgs rule
	// * 
	// * Represents a list of formal arguments. 
	// */ FormalArgs:
	//	args+=[FormalArg] (',' args+=[FormalArg])*;
	public FormalArgsElements getFormalArgsAccess() {
		return pFormalArgs;
	}
	
	public ParserRule getFormalArgsRule() {
		return getFormalArgsAccess().getRule();
	}
	
	///* FormalArg rule
	// * 
	// * It should accept a wild card ('_') or something like 'int x'  
	// */ FormalArg:
	//	{Wildcard} '_'
	//	| {Formal} argument=JvmArgumentTypeReference;
	public FormalArgElements getFormalArgAccess() {
		return pFormalArg;
	}
	
	public ParserRule getFormalArgRule() {
		return getFormalArgAccess().getRule();
	}
	
	///* OrderSpec rule
	// * 
	// * Uses a regular expression on the labeled 
	// * events. 
	// */ OrderSpec:
	//	{OrderSpec} 'ORDER' order=EventExp;
	public OrderSpecElements getOrderSpecAccess() {
		return pOrderSpec;
	}
	
	public ParserRule getOrderSpecRule() {
		return getOrderSpecAccess().getRule();
	}
	
	///* EventExp 
	// * 
	// * An expression language to declare the order of events 
	// * (or method calls). This order resembles a regular 
	// * expression. 
	// *  
	// * Here we use a well-known idiom to avoid left-recursion in 
	// * grammars, named left-factoring.  
	// * 
	// * Specifically to the context of XText, this video 
	// * might be useful to understand this design: 
	// * 
	// * https://www.youtube.com/watch?v=d3JymwcB_TM&feature=youtu.be
	// * 
	// * Note: It was necessary to allow the backtrack feature 
	// * here. Take a look at the mwe2 file.  
	// */ EventExp:
	//	{Optional} exp=ChoiceExp '?'
	//	| {ZeroOrMore} exp=ChoiceExp '*'
	//	| {OneOrMore} exp=ChoiceExp '+'
	//	| {ChoiceExp} exp=ChoiceExp;
	public EventExpElements getEventExpAccess() {
		return pEventExp;
	}
	
	public ParserRule getEventExpRule() {
		return getEventExpAccess().getRule();
	}
	
	//ChoiceExp EventExp:
	//	SequenceExp => ({ChoiceExp.left=current} '|' right=SequenceExp)*;
	public ChoiceExpElements getChoiceExpAccess() {
		return pChoiceExp;
	}
	
	public ParserRule getChoiceExpRule() {
		return getChoiceExpAccess().getRule();
	}
	
	//SequenceExp EventExp:
	//	PrimaryExp => ({SequenceExp.left=current} ',' right=PrimaryExp)*;
	public SequenceExpElements getSequenceExpAccess() {
		return pSequenceExp;
	}
	
	public ParserRule getSequenceExpRule() {
		return getSequenceExpAccess().getRule();
	}
	
	//PrimaryExp EventExp:
	//	label=ID
	//	| '(' ChoiceExp ')';
	public PrimaryExpElements getPrimaryExpAccess() {
		return pPrimaryExp;
	}
	
	public ParserRule getPrimaryExpRule() {
		return getPrimaryExpAccess().getRule();
	}
	
	//JvmTypeReference:
	//	JvmParameterizedTypeReference => ({JvmGenericArrayTypeReference.componentType=current} ArrayBrackets)*
	//	| XFunctionTypeRef;
	public XtypeGrammarAccess.JvmTypeReferenceElements getJvmTypeReferenceAccess() {
		return gaXtype.getJvmTypeReferenceAccess();
	}
	
	public ParserRule getJvmTypeReferenceRule() {
		return getJvmTypeReferenceAccess().getRule();
	}
	
	//ArrayBrackets:
	//	'[' ']';
	public XtypeGrammarAccess.ArrayBracketsElements getArrayBracketsAccess() {
		return gaXtype.getArrayBracketsAccess();
	}
	
	public ParserRule getArrayBracketsRule() {
		return getArrayBracketsAccess().getRule();
	}
	
	//XFunctionTypeRef:
	//	('(' (paramTypes+=JvmTypeReference (',' paramTypes+=JvmTypeReference)*)? ')')? '=>' returnType=JvmTypeReference;
	public XtypeGrammarAccess.XFunctionTypeRefElements getXFunctionTypeRefAccess() {
		return gaXtype.getXFunctionTypeRefAccess();
	}
	
	public ParserRule getXFunctionTypeRefRule() {
		return getXFunctionTypeRefAccess().getRule();
	}
	
	//JvmParameterizedTypeReference:
	//	type=[JvmType|QualifiedName] (=> '<' arguments+=JvmArgumentTypeReference (',' arguments+=JvmArgumentTypeReference)*
	//	'>' (=> ({JvmInnerTypeReference.outer=current} '.') type=[JvmType|ValidID] (=> '<' arguments+=JvmArgumentTypeReference
	//	(',' arguments+=JvmArgumentTypeReference)* '>')?)*)?;
	public XtypeGrammarAccess.JvmParameterizedTypeReferenceElements getJvmParameterizedTypeReferenceAccess() {
		return gaXtype.getJvmParameterizedTypeReferenceAccess();
	}
	
	public ParserRule getJvmParameterizedTypeReferenceRule() {
		return getJvmParameterizedTypeReferenceAccess().getRule();
	}
	
	//JvmArgumentTypeReference JvmTypeReference:
	//	JvmTypeReference | JvmWildcardTypeReference;
	public XtypeGrammarAccess.JvmArgumentTypeReferenceElements getJvmArgumentTypeReferenceAccess() {
		return gaXtype.getJvmArgumentTypeReferenceAccess();
	}
	
	public ParserRule getJvmArgumentTypeReferenceRule() {
		return getJvmArgumentTypeReferenceAccess().getRule();
	}
	
	//JvmWildcardTypeReference:
	//	{JvmWildcardTypeReference} '?' (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*
	//	| constraints+=JvmLowerBound constraints+=JvmLowerBoundAnded*)?;
	public XtypeGrammarAccess.JvmWildcardTypeReferenceElements getJvmWildcardTypeReferenceAccess() {
		return gaXtype.getJvmWildcardTypeReferenceAccess();
	}
	
	public ParserRule getJvmWildcardTypeReferenceRule() {
		return getJvmWildcardTypeReferenceAccess().getRule();
	}
	
	//JvmUpperBound:
	//	'extends' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundElements getJvmUpperBoundAccess() {
		return gaXtype.getJvmUpperBoundAccess();
	}
	
	public ParserRule getJvmUpperBoundRule() {
		return getJvmUpperBoundAccess().getRule();
	}
	
	//JvmUpperBoundAnded JvmUpperBound:
	//	'&' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmUpperBoundAndedElements getJvmUpperBoundAndedAccess() {
		return gaXtype.getJvmUpperBoundAndedAccess();
	}
	
	public ParserRule getJvmUpperBoundAndedRule() {
		return getJvmUpperBoundAndedAccess().getRule();
	}
	
	//JvmLowerBound:
	//	'super' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundElements getJvmLowerBoundAccess() {
		return gaXtype.getJvmLowerBoundAccess();
	}
	
	public ParserRule getJvmLowerBoundRule() {
		return getJvmLowerBoundAccess().getRule();
	}
	
	//JvmLowerBoundAnded JvmLowerBound:
	//	'&' typeReference=JvmTypeReference;
	public XtypeGrammarAccess.JvmLowerBoundAndedElements getJvmLowerBoundAndedAccess() {
		return gaXtype.getJvmLowerBoundAndedAccess();
	}
	
	public ParserRule getJvmLowerBoundAndedRule() {
		return getJvmLowerBoundAndedAccess().getRule();
	}
	
	//JvmTypeParameter:
	//	name=ValidID (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*)?;
	public XtypeGrammarAccess.JvmTypeParameterElements getJvmTypeParameterAccess() {
		return gaXtype.getJvmTypeParameterAccess();
	}
	
	public ParserRule getJvmTypeParameterRule() {
		return getJvmTypeParameterAccess().getRule();
	}
	
	//QualifiedName:
	//	ValidID ('.' ValidID)*;
	public XtypeGrammarAccess.QualifiedNameElements getQualifiedNameAccess() {
		return gaXtype.getQualifiedNameAccess();
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	QualifiedName '.' '*';
	public XtypeGrammarAccess.QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return gaXtype.getQualifiedNameWithWildcardAccess();
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//ValidID:
	//	ID;
	public XtypeGrammarAccess.ValidIDElements getValidIDAccess() {
		return gaXtype.getValidIDAccess();
	}
	
	public ParserRule getValidIDRule() {
		return getValidIDAccess().getRule();
	}
	
	//XImportSection:
	//	importDeclarations+=XImportDeclaration+;
	public XtypeGrammarAccess.XImportSectionElements getXImportSectionAccess() {
		return gaXtype.getXImportSectionAccess();
	}
	
	public ParserRule getXImportSectionRule() {
		return getXImportSectionAccess().getRule();
	}
	
	//XImportDeclaration:
	//	'import' (static?='static' extension?='extension'? importedType=[JvmDeclaredType|QualifiedNameInStaticImport]
	//	(wildcard?='*' | memberName=ValidID) | importedType=[JvmDeclaredType|QualifiedName] |
	//	importedNamespace=QualifiedNameWithWildcard) ';'?;
	public XtypeGrammarAccess.XImportDeclarationElements getXImportDeclarationAccess() {
		return gaXtype.getXImportDeclarationAccess();
	}
	
	public ParserRule getXImportDeclarationRule() {
		return getXImportDeclarationAccess().getRule();
	}
	
	//QualifiedNameInStaticImport:
	//	(ValidID '.')+;
	public XtypeGrammarAccess.QualifiedNameInStaticImportElements getQualifiedNameInStaticImportAccess() {
		return gaXtype.getQualifiedNameInStaticImportAccess();
	}
	
	public ParserRule getQualifiedNameInStaticImportRule() {
		return getQualifiedNameInStaticImportAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '$' | '_') ('a'..'z' | 'A'..'Z' | '$' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaXtype.getIDRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"'? |
	//	"'" ('\\' . | !('\\' | "'"))* "'"?;
	public TerminalRule getSTRINGRule() {
		return gaXtype.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaXtype.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaXtype.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaXtype.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaXtype.getANY_OTHERRule();
	}
}
