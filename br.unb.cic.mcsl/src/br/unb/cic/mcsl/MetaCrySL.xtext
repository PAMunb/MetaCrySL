grammar br.unb.cic.mcsl.MetaCrySL with org.eclipse.xtext.xbase.Xtype


generate metaCrySL "http://www.unb.br/cic/mcsl/MetaCrySL"


Model:
	metaCrySL = Spec;

/* Spec rule 
 * 
 * This is the start symbol of our MetaCrySL grammar. 
 * In MetaCrySL, we can annotate a specification
 * as being abstract and a spec can also refer to an 
 * abstract type. Each specification comprises 
 * (or might comprise) definitions for object 
 * declarations, events and order, constraints, 
 * and so on. 
 */	
Spec
 : 'ABSTRACT'? 'SPEC' className = JvmTypeReference
     objectSpec    = ObjectSpec
     (forbiddenSpec = ForbiddenSpec)? 
     (eventSpec     = EventSpec)?  
     (orderSpec     = OrderSpec)?
     (constraintSpec = ConstraintSpec)?
 ;
    
/* ObjectSpec rule
 * 
 * It corresponds to the declaration of the 
 * variables (names) used throughout the 
 * specification. 
 */    
ObjectSpec: {ObjectSpec} 'OBJECTS' ':' objects += Object+ ;    

/* Object rule
 * 
 * Allows the specification of a typed 
 * variable that can be used in the remaining 
 * sections of the specification. 
 */
Object: {Object} type = JvmTypeReference varName = ID ';' ;

/* ForbiddenSpec */
ForbiddenSpec: {ForbiddenSpec} 'FORBIDDEN' forbidenMethods += ForbiddenMethod+;

ForbiddenMethod: {Forbidden} method = ID '(' (args ?= FormalArgs)? ')' ('=>' alternative ?= ID)? ';';

/* EventSpec rule 
 * 
 * This rule defines the EVENTS session. It should accept 
 * the following: 
 *  
 *   EVENTS: 
 *     c1 : method1();           //event method
 *     c2 : method2(int x);      //event method
 *     
 *     cs := c1 | c2 ;           //event aggregate
 */
EventSpec : {EventSpec} 'EVENTS' events += Event+ ;

/* Event rule
 * 
 * An event is either a labeled method or an 
 * aggregation of labels. Note that we can assign 
 * a 'method call' to a variable. 
 */
Event
 : {EventMethod}    (label = ID ':') (var = ID '=')? method = MethodDef ';'
 | {EventAggregate} (label = ID ':=') aggregate = AggregateList ';'	
 ;

/* AggregateList rule. 
 * 
 * Represents a list of labels: 'l1 | l2 | l3'
 */
AggregateList : labels += ID ('|' labels+=ID)*;

/* MethodDef rule. 
 * 
 * It should accept 'method()' or method(int x, int y)
 * 
 * (note) 
 * this way to express lists, with a list 
 * separator in XText, is really weird. 
 */
MethodDef: methodName = ID '(' (args ?= FormalArgs?) ')' ;

/* FormalArgs rule
 * 
 * Represents a list of formal arguments. 
 */
FormalArgs: args += [FormalArg] (',' args += [FormalArg])* ;

/* FormalArg rule
 * 
 * It should accept a wild card ('_') or something like 'int x'  
 */
FormalArg 
 : {Wildcard} '_'
 | {Formal} (argument = JvmArgumentTypeReference)	 
 ;
 

/* OrderSpec rule
 * 
 * Uses a regular expression on the labeled 
 * events. 
 */
 
OrderSpec: {OrderSpec} 'ORDER' order = EventExp ; 

/* EventExp 
 * 
 * An expression language to declare the order of events 
 * (or method calls). This order resembles a regular 
 * expression. 
 *  
 * Here we use a well-known idiom to avoid left-recursion in 
 * grammars, named left-factoring.  
 * 
 * Specifically to the context of XText, this video 
 * might be useful to understand this design: 
 * 
 * https://www.youtube.com/watch?v=d3JymwcB_TM&feature=youtu.be
 * 
 * Note: It was necessary to allow the backtrack feature 
 * here. Take a look at the mwe2 file. Backtracking might 
 * be quite expensive, so perhaps we should investigate an 
 * alternative to this design.  
 */
EventExp
 : {Optional}   exp = ChoiceExp '?'
 | {ZeroOrMore} exp = ChoiceExp '*' 
 | {OneOrMore}  exp = ChoiceExp '+'	
 | {ChoiceExp}  exp = ChoiceExp 
 ;

ChoiceExp returns EventExp
 : SequenceExp => ({ChoiceExp.left = current}'|' right = SequenceExp)* 	
 ;
 
SequenceExp returns EventExp
 : PrimaryExp => ({SequenceExp.left = current} ',' right = PrimaryExp)*;
  
PrimaryExp returns EventExp
 : label = ID
 | '(' ChoiceExp ')' 	
 ;  
 
/* ConstraintSpec rule
 * 
 * Defines constraints for objects defined under OBJECTS clause
 * and used as parameters or return values in the EVENTS section
*/

ConstraintSpec: {ConstraintSpec} 'CONSTRAINTS' constraints += ConstraintsExp;
 
ConstraintsExp:
 	varName = ID 'in' '{'constraints+=STRING (',' constraints+=STRING)* '}' ';'
 ;

