/*
 * generated by Xtext 2.22.0
 */
package br.unb.cic.mcsl.generator

import br.unb.cic.mcsl.MetaCrySLStandaloneSetup
import br.unb.cic.mcsl.metaCrySL.Configuration
import br.unb.cic.mcsl.metaCrySL.Model
import com.google.inject.Inject
import java.io.FileReader
import java.nio.file.Files
import java.nio.file.Paths
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.parser.IParseResult
import org.eclipse.xtext.parser.IParser
import br.unb.cic.mcsl.metaCrySL.Refinement
import br.unb.cic.mcsl.metaCrySL.Spec
import java.util.HashMap;
import java.util.ArrayList
import java.util.Optional
import org.eclipse.emf.ecore.EObject
import br.unb.cic.mcsl.metaCrySL.impl.MetaCrySLImpl
import br.unb.cic.mcsl.metaCrySL.MetaCrySL
import br.unb.cic.mcsl.metaCrySL.impl.RefinementImpl
import br.unb.cic.mcsl.metaCrySL.impl.MetaCrySLFactoryImpl
import java.util.Iterator
import java.util.Map
import java.util.Collection
import br.unb.cic.mcsl.metaCrySL.RefinementOpr
import br.unb.cic.mcsl.metaCrySL.impl.AddConstraintImpl
import br.unb.cic.mcsl.metaCrySL.impl.DefineLiteralSetImpl
import br.unb.cic.mcsl.metaCrySL.Constraint
import javax.swing.text.html.parser.Entity
import org.eclipse.emf.common.util.URI

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MetaCrySLGenerator extends AbstractGenerator {

	@Inject
	private IParser parser;
	
	// hashmap to associate classnames to a list of refinements
	val specRefs = new HashMap<String, ArrayList<Refinement>>
	// hashmap to associate parsed SPEC to a merged REFINEMENT
	val specification = new HashMap<Spec, Refinement>
	// list with all refs to be parsed
	val refs = new ArrayList<String>
	val specs = new ArrayList<Spec>
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(Spec)) {
        	fsa.generateFile(
            	"teste.crysl",
            	generateCode(URI.createURI("./test-resources/cryptsl-files/basicConfig.config").path))
    	}
	}
	
	def Refinement mergeRefinements(String name, ArrayList<Refinement> refs) {
		val newRefinement = (new MetaCrySLFactoryImpl()).createRefinement()
		val operationsList = new ArrayList<RefinementOpr>;
		newRefinement.name = name
		
		// Creates a flat list with all refinement operations
		
		// TODO: treat `rename` and `define` as special cases 		
		val oprList = refs.map(r | r.refinements)
		for(list: oprList) {
			for(el: list) {
				operationsList.add(el)
			}
		}
		
		for(el: operationsList) {
			newRefinement.refinements.add(el)
		}
		
		return newRefinement
	}
	
	def Optional<String> getExtensionByStringHandling(String filename) {
	    return Optional.ofNullable(filename)
	      .filter(f | f.contains("."))
	      .map(f | f.substring(filename.lastIndexOf(".") + 1));
	}
	
	
	def String generateCode(String configuration) {
		val config = parseConfiguration(configuration)
		val src = config.inputDir
		
		val modules = config.modules
		
		// TODO: associate classNames to refinements (get className from refinement jvm type)
		for(m: modules) {
			// get all files with .mcsl and add to a list
			if(getExtensionByStringHandling(m.module).get() == 'mcsl') {
				val parsedSpec = parseSpec(src + m.module)
				specs.add(parsedSpec) // add parsed spec to list of specs
			}
			else if(getExtensionByStringHandling(m.module).get() == 'ref') {
				val parsedRef = parseRefinement(src + m.module)
				
				// check if current ref className type is already present in the Hashmap
				// if not, add to hashmap and add ref to the associated <ArrayList>
				// if yes, find the key and add ref to associated <ArrayList>
				
				val refsList = if (!specRefs.containsKey(parsedRef.type) ) {
					new ArrayList<Refinement>
				} else {
					specRefs.get(parsedRef.type)
				}
				refsList.add(parsedRef)
				specRefs.put(parsedRef.type, refsList)
			}			
		}
		
		// Merge refinements and associate with individual SPEC file
		for(entry : specRefs.entrySet()) {
			val ref = mergeRefinements(entry.getKey(), entry.getValue())
			for(spec: specs) {
				if(spec.className == ref.name) {
					specification.put(spec, ref)
				}
			}
		}
		
		
		// TODO: apply refinements to SPEC file
		for(spec: specification.entrySet()) {
			val refinement = spec.getValue()
			val finalSpec = spec.getKey()
			for(opr: refinement.refinements) { // Check for each possible expression type
				if(opr instanceof AddConstraintImpl) {
					val newConstraint = (new MetaCrySLFactoryImpl()).createConstraint()
					newConstraint.exp = opr.constraint
					finalSpec.constraintSpec.constraints.add(newConstraint)
				}
				else if(opr instanceof DefineLiteralSetImpl) {
					println(opr)
				}
				
				// Call the compiler
				val output = compile(finalSpec)
				return output as String
			}
		}
	}
	
	// Template for outputting final CrySL file from a Spec model
	private def compile(Spec e)'''
		ABSTRACT SPEC «e.className»
	'''
	
	protected def Configuration parseConfiguration(String configuration) {
		val path = Paths.get(configuration)
		
		if(!Files.exists(path)) {
			throw new RuntimeException("The configuration file does not exist " + path)
		}
		
		setupParser()
		
		val result = parser.parse(new FileReader(configuration))
		
		if(result.syntaxErrors.size > 0) {
			throw new RuntimeException("Parser error: " + result.syntaxErrors)
		}
		(result.rootASTElement as Configuration).configuration
	}
	
	def Refinement parseRefinement(String refinement) {
		val path = Paths.get(refinement)
		
		if(!Files.exists(path)) {
			throw new RuntimeException("The configuration file does not exist " + path)
		}
		
		setupParser()
		
		val result = parser.parse(new FileReader(refinement))
		
		if(result.syntaxErrors.size > 0) {
			throw new RuntimeException("Parser error: " + result.syntaxErrors)
		}
		(result.rootASTElement as Refinement).refinement
	}
	
	protected def Spec parseSpec(String spec) {
		val path = Paths.get(spec)
		
		if(!Files.exists(path)) {
			throw new RuntimeException("The spec file does not exist " + path)
		}
		
		setupParser()
		
		val result = parser.parse(new FileReader(spec))
		
		if(result.syntaxErrors.size > 0) {
			throw new RuntimeException("Parser error: " + result.syntaxErrors)
		}
		(result.rootASTElement as MetaCrySL).spec
	}
	
	def void setupParser() {
        val injector = new MetaCrySLStandaloneSetup().createInjectorAndDoEMFRegistration()
        injector.injectMembers(this)
    }
}
